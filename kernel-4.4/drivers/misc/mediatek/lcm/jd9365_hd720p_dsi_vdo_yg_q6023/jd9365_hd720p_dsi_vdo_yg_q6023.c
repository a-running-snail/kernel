#ifndef BUILD_LK
#include <linux/string.h>
#include <linux/kernel.h>
#endif
#include "lcm_drv.h"

#ifdef BUILD_LK
	#include <platform/upmu_common.h>
	#include <platform/upmu_hw.h>

	#include <platform/mt_gpio.h>
	#include <platform/mt_i2c.h>
	#include <platform/mt_pmic.h>
	#include <string.h>
#else
#ifdef CONFIG_MTK_LEGACY
	#include <mach/mt_pm_ldo.h>	/* hwPowerOn */
	#include <mach/upmu_common.h>
	#include <mach/upmu_sw.h>
	#include <mach/upmu_hw.h>
	#include <mach/mt_gpio.h>
#endif
#endif

#ifdef CONFIG_MTK_LEGACY
#include <cust_gpio_usage.h>
#ifndef CONFIG_FPGA_EARLY_PORTING
#include <cust_i2c.h>
#endif
#endif

#ifndef BUILD_LK
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/init.h>
#include <linux/list.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>
#include <linux/irq.h>
#include <linux/uaccess.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/platform_device.h>
#include <linux/string.h>
#include <linux/wait.h>
#include <linux/i2c.h>
#include <linux/gpio.h>
#include "lcm_define.h"
#include "lcm_drv.h"
#include "lcm_i2c.h"
#endif

#ifdef BUILD_LK
#include <platform/upmu_common.h>
#include <platform/upmu_hw.h>
#include <platform/mt_gpio.h>
#include <platform/mt_i2c.h>
#include <platform/mt_pmic.h>
#include <string.h>
#else
//#ifdef CONFIG_MTK_LEGACY
//#include <mach/mt_pm_ldo.h>	/* hwPowerOn */
#include <mt-plat/upmu_common.h>
#include <mach/upmu_sw.h>
#include <mach/upmu_hw.h>
#endif
//#endif
//#ifdef CONFIG_MTK_LEGACY
//#include <mach/mt_gpio.h>
//#include <cust_gpio_usage.h>
//#include <cust_i2c.h>
//#endif


// ---------------------------------------------------------------------------
//  Local Constants
// ---------------------------------------------------------------------------
#ifdef BUILD_LK
//~ #define GPIO_LCD_PWR_EN_LK	GPIO_LCD_ENN_PIN
//~ #define GPIO_LCD_PWR2_EN_LK GPIO_LCM_PWR2_EN
#endif

#define FRAME_WIDTH  										(720)
#define FRAME_HEIGHT 										(1520)

#define REGFLAG_DELAY             							0XFC
#define REGFLAG_END_OF_TABLE      							0xFD   // END OF REGISTERS MARKER

#define LCM_ID	0x70

#define LCM_DSI_CMD_MODE									0

// ---------------------------------------------------------------------------
//  Local Variables
// ---------------------------------------------------------------------------

static LCM_UTIL_FUNCS lcm_util = {0};

#define SET_RESET_PIN(v)    								(lcm_util.set_reset_pin((v)))

#define UDELAY(n) 											(lcm_util.udelay(n))
#define MDELAY(n) 											(lcm_util.mdelay(n))


// ---------------------------------------------------------------------------
//  Local Functions
// ---------------------------------------------------------------------------

#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)	lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
#define dsi_set_cmdq(pdata, queue_size, force_update)		lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
#define wrtie_cmd(cmd)										lcm_util.dsi_write_cmd(cmd)
#define write_regs(addr, pdata, byte_nums)					lcm_util.dsi_write_regs(addr, pdata, byte_nums)
#define read_reg(cmd)											lcm_util.dsi_dcs_read_lcm_reg(cmd)
#define read_reg_v2(cmd, buffer, buffer_size)				lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)


       

/* physical size in um */
#define LCM_PHYSICAL_WIDTH									(65*1000)
#define LCM_PHYSICAL_HEIGHT									(130*1000)
//#define LCM_DENSITY	(320)
 struct LCM_setting_table {
    unsigned char cmd;
    unsigned char count;
    unsigned char para_list[64];
};

static struct LCM_setting_table lcm_initialization_setting[] = {


{0x41,1,{0x5A}},
{0x4C,1,{0x03}},
{0x41,2,{0x5A,0x03}},
{0x80,2,{0xA9,0x00}},
{0x41,2,{0x5A,0x09}},
{0x80,5,{0x64,0x00,0x64,0x00,0x00}},
{0x41,2,{0x5A,0x0A}},
{0x80,16,{0xA5,0x15,0xA5,0xAA,0xA5,0x88,0x42,0x38,0x03,0x03,0x07,0x05,0x4D,0x61,0x46,0x5A}},
{0x90,16,{0x0C,0x0F,0x22,0x00,0x2A,0x18,0x64,0x00,0x88,0x03,0x03,0xEE,0xEE,0x00,0x3F,0x2A}},
{0xA0,16,{0x00,0x30,0x02,0x32,0x11,0x0D,0x60,0x01,0xFF,0xFF,0x03,0x40,0x42,0x0F,0x94,0x11}},
{0xB0,16,{0xE8,0x03,0x00,0x00,0x11,0x0D,0x60,0x00,0xFF,0xFF,0x03,0xFF,0x34,0x0C,0x0F,0x0E}},
{0xC0,10,{0x1F,0x03,0x00,0x08,0x20,0x34,0x00,0x00,0x00,0x00}},
{0x41,2,{0x5A,0x0B}},
{0x80,16,{0xFF,0xBE,0xE6,0x00,0x00,0x03,0x0A,0x13,0x1A,0x22,0x30,0x3C,0x3D,0x4A,0x4F,0x69}},
{0x90,16,{0x97,0x7E,0x7B,0x6D,0x62,0x55,0x43,0x38,0x2E,0x1C,0x07,0x01,0x00,0x03,0x0A,0x13}},
{0xA0,16,{0x1A,0x22,0x30,0x3C,0x3D,0x4A,0x4F,0x69,0x97,0x7E,0x7B,0x6D,0x62,0x55,0x43,0x38}},
{0xB0,5,{0x2E,0x1C,0x07,0x01,0x00}},
{0x41,2,{0x5A,0x0C}},
{0x80,16,{0x00,0x00,0x20,0x42,0x00,0x00,0x80,0x05,0x54,0x00,0x00,0x00,0x20,0x42,0x00,0x00}},
{0x90,2,{0x80,0x05}},
{0x41,2,{0x5A,0x0D}},
{0x80,16,{0x7A,0xD0,0x02,0xF0,0x05,0xFA,0x00,0xF0,0x00,0x0A,0x0A,0x0A,0x0A,0x00,0x01,0x03}},
{0x90,16,{0x00,0x00,0x00,0x00,0xAC,0xA2,0x2A,0x00,0x00,0x00,0xAC,0xA2,0x2A,0x57,0x31,0x00}},
{0xA0,16,{0x00,0x00,0x00,0x00,0x00,0xAC,0xA2,0x2A,0xAA,0xC2,0x2A,0xAC,0xA2,0x2A,0xAA,0xC2}},
{0xB0,6,{0x2A,0x00,0x00,0x00,0xAA,0x52}},
{0x41,2,{0x5A,0x0E}},
{0x80,12,{0xF0,0xB1,0x71,0xEF,0x4B,0x20,0x37,0x0F,0xAA,0xAA,0x00,0x00}},
{0x41,2,{0x5A,0x0F}},
{0x80,11,{0xFF,0x00,0x55,0x55,0x23,0x88,0x88,0x1C,0x00,0x5A,0x5A}},
{0x41,2,{0x5A,0x10}},
{0x80,16,{0xB5,0x45,0x09,0x18,0x01,0x3C,0x94,0x32,0x10,0xC4,0xC4,0x04,0x00,0x60,0xC0,0x00}},
{0x90,16,{0x04,0x00,0x00,0x86,0x10,0x31,0x98,0x34,0x34,0x34,0x26,0x26,0x3E,0x1A,0x62,0x20}},
{0xA0,4,{0x0C,0x40,0x00,0x8A}},
{0x41,2,{0x5A,0x11}},
{0x80,16,{0x00,0x00,0x03,0xE7,0x1F,0x17,0x20,0x48,0x60,0xD2,0x8F,0x1A,0x30,0x88,0x41,0x8A}},
{0x90,15,{0x39,0x28,0xA9,0xC5,0x9A,0x7B,0xF0,0x07,0x7E,0xE0,0x07,0x7E,0x20,0x10,0x00}},
{0x41,2,{0x5A,0x12}},
{0x80,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x37}},
{0x90,16,{0x2D,0x23,0x19,0x0F,0x05,0xFB,0xF1,0xE7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
{0xA0,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
{0xB0,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2D,0x23,0x05,0xFB,0x00,0x2D,0x23}},
{0xC0,4,{0x05,0xFB,0x00,0x01}},
{0x41,2,{0x5A,0x13}},
{0x80,16,{0xFD,0x0F,0x00,0x0C,0x00,0x80,0x80,0x87,0x00,0x07,0x22,0x06,0xE7,0xB9,0x86,0x1A}},
{0x90,16,{0x32,0x00,0xA2,0x2D,0x65,0x00,0x00,0x00,0x00,0xD0,0xC9,0xB7,0xFE,0x26,0x6F,0x32}},
{0xA0,3,{0x22,0x90,0x04}},
{0x41,2,{0x5A,0x14}},
{0x80,16,{0x01,0x02,0x40,0x5E,0xD1,0xDF,0xEF,0xF7,0xFB,0xFD,0x02,0x00,0x00,0xF8,0x8A,0x0F}},
{0x90,16,{0x4D,0x7A,0x40,0x6C,0x68,0xD2,0x03,0xE2,0x42,0x93,0x1E,0x10,0x13,0x9A,0xF4,0x00}},
{0xA0,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x02,0x00,0x00,0x00,0x00,0x00}},
{0xB0,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x5F,0xF3,0x55,0x00,0x80,0x42}},
{0xC0,16,{0xA1,0xF0,0x0E,0xF0,0xEB,0x01,0xA5,0x38,0xDE,0x00,0x7E,0x3D,0xA0,0x14,0xC7,0x0B}},
{0xD0,16,{0xC0,0xAF,0x07,0x94,0xE2,0x78,0x05,0xF8,0xF5,0x80,0x52,0x1C,0xEF,0x02,0xBF,0x1E}},
{0xE0,16,{0x50,0x8A,0xE3,0x4D,0xE0,0xD7,0x03,0x4A,0x71,0xBC,0x07,0xFC,0x7A,0x40,0x29,0x8E}},
{0xF0,16,{0xB7,0x80,0x5F,0x0F,0x28,0xC5,0xF1,0x02,0x7E,0xBF,0x31,0x00,0x00,0x00,0x00,0x00}},
{0x41,2,{0x5A,0x15}},
{0x80,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xB0,0xC1,0xEF}},
{0x90,16,{0xE7,0x01,0xF2,0x95,0x88,0x51,0xAB,0x0D,0x22,0x23,0x2F,0x62,0xD4,0x6A,0x83,0xC8}},
{0xA0,16,{0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
{0xB0,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0x00,0xE0,0x01,0x28,0x6D,0x68,0x5A}},
{0xC0,16,{0xD2,0x2A,0x18,0x8A,0x03,0xAA,0x6D,0xDB,0xB6,0x6D,0xDB,0xB6,0x6D,0xDB,0x86,0x2A}},
{0xD0,16,{0x44,0xAD,0x0C,0x42,0x00,0xA0,0xD9,0xB6,0x6D,0xDB,0xB6,0x6D,0xDB,0xB6,0x6D,0x68}},
{0xE0,16,{0x52,0xD0,0x0A,0x10,0x08,0x03,0xAA,0x6D,0xDB,0xB6,0x6D,0xDB,0xB6,0x6D,0xDB,0x86}},
{0xF0,16,{0xAA,0x64,0xAD,0x8E,0x62,0x08,0xA0,0xD9,0xB6,0x6D,0xDB,0xB6,0x6D,0xDB,0xB6,0x00}},
{0x41,2,{0x5A,0x16}},
{0x80,16,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
{0x90,10,{0x00,0x00,0x00,0x00,0x80,0x42,0x28,0x01,0x00,0x00}},
{0x41,2,{0x5A,0x18}},
{0x80,16,{0xEF,0xBD,0xF7,0xDE,0x7B,0xEF,0xBD,0x07,0x08,0x08,0x0A,0x0C,0x0C,0x0C,0x0C,0x0C}},
{0x90,16,{0x0C,0x0C,0x0C,0x5C,0x09,0xA8,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0x5A}},
{0xA0,16,{0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x09,0x04,0xFF,0x00,0x80}},
{0xB0,15,{0x80,0x00,0x04,0x20,0x00,0x01,0x08,0x40,0x00,0x02,0x10,0x80,0x00,0x04,0x00}},
{0x41,2,{0x5A,0x19}},
{0x80,16,{0xC7,0xB5,0xA6,0x9B,0x93,0x8C,0x86,0x81,0x80,0x80,0x80,0x80,0x00,0xF0,0xFF,0xFF}},
{0x90,16,{0xFF,0xFF,0xFF,0xBF,0x7F,0x3F,0x0F,0xFF,0xAF,0xB5,0x71,0x0E,0x6C,0x4A,0x69,0x08}},
{0xA0,4,{0x00,0x00,0x48,0x00}},
{0x41,2,{0x5A,0x1A}},
{0x80,16,{0xFF,0x04,0x04,0x08,0x0C,0x00,0x10,0x14,0x18,0x1C,0x00,0x20,0x28,0x30,0x38,0x00}},
{0x90,16,{0x40,0x48,0x50,0x58,0x00,0x60,0x68,0x70,0x78,0x00,0x80,0x88,0x90,0x98,0x00,0xA0}},
{0xA0,16,{0xA8,0xB0,0xB8,0x00,0xC0,0xC8,0xD0,0xD8,0x00,0xE0,0xE8,0xF0,0xF8,0x00,0xFC,0xFE}},
{0xB0,16,{0xFF,0x00,0x00,0x04,0x08,0x0C,0x00,0x10,0x14,0x18,0x1C,0x00,0x20,0x28,0x30,0x38}},
{0xC0,16,{0x00,0x40,0x48,0x50,0x58,0x00,0x60,0x68,0x70,0x78,0x00,0x80,0x88,0x90,0x98,0x00}},
{0xD0,16,{0xA0,0xA8,0xB0,0xB8,0x00,0xC0,0xC8,0xD0,0xD8,0x00,0xE0,0xE8,0xF0,0xF8,0x00,0xFC}},
{0xE0,16,{0xFE,0xFF,0x00,0x00,0x04,0x08,0x0C,0x00,0x10,0x14,0x18,0x1C,0x00,0x20,0x28,0x30}},
{0xF0,16,{0x38,0x00,0x40,0x48,0x50,0x58,0x00,0x60,0x68,0x70,0x78,0x00,0x80,0x88,0x90,0x98}},
{0x41,2,{0x5A,0x1B}},
{0x80,16,{0x00,0xA0,0xA8,0xB0,0xB8,0x00,0xC0,0xC8,0xD0,0xD8,0x00,0xE0,0xE8,0xF0,0xF8,0x00}},
{0x90,5,{0xFC,0xFE,0xFF,0x00,0x00}},
{0x41,2,{0x5A,0x1C}},
{0x80,16,{0x33,0x22,0x00,0x03,0x5A,0x02,0x5A,0x54,0xE5,0xFF,0xC7,0x20,0x18,0x28,0x18,0x08}},
{0x90,16,{0x10,0x0C,0x07,0x09,0x06,0x06,0x0A,0x10,0x0C,0x09,0x0B,0x06,0x26,0xF2,0x78,0x40}},
{0xA0,16,{0x20,0x08,0x08,0x06,0x13,0xC0,0x34,0x1E,0x0A,0x08,0x66,0xD1,0xA0,0x1C,0x20,0x20}},
{0xB0,16,{0x18,0x04,0x20,0x00,0xC0,0x04,0x28,0x01,0x4C,0x00,0x23,0x18,0x10,0x0A,0x06,0xC9}},
{0xC0,16,{0x04,0x70,0x41,0x58,0x54,0xB5,0x4A,0x55,0x15,0x00,0x78,0xF8,0x99,0x99,0x99,0x99}},
{0xD0,16,{0x99,0x99,0x88,0x88,0x88,0x88,0x88,0x88,0x08,0xC4,0xE3,0x81,0x00,0x20,0x80,0x27}},
{0xE0,16,{0xE2,0x89,0x00,0x00,0x00,0x00,0x40,0x00,0x80,0x30,0x04,0x41,0x06,0x00,0x00,0x00}},
{0xF0,16,{0x00,0x92,0x24,0x49,0x92,0x04,0x00,0x00,0x00,0x00,0x92,0x04,0x00,0xC0,0x03,0x40}},
{0x41,2,{0x5A,0x1D}},
{0x80,16,{0x00,0x01,0x54,0x0B,0x23,0x18,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
{0x41,2,{0x5A,0x22}},
{0x80,15,{0x00,0x5E,0x00,0x00,0x00,0x00,0x00,0x00,0x5E,0x00,0x00,0x00,0x00,0x00,0x00}},
{0x41,2,{0x5A,0x24}},
{0x80,16,{0x2D,0xD3,0x00,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x9F,0x00,0xAA,0x3E,0x00}},
{0x90,4,{0x00,0x00,0x00,0x00}},
{0x41,2,{0x5A,0x25}},
{0x80,16,{0x01,0x05,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}},
{0x90,11,{0x0F,0x00,0x00,0x24,0x00,0x00,0x00,0x00,0xFF,0x07,0x35}},
{0x41,2,{0x5A,0x26}},
{0x80,16,{0x00,0x83,0x00,0xFF,0xFF,0x60,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x2F,0xE7}},
{0x90,3,{0x5A,0xA5,0x5A}},
{0x90,1,{0xA5}},
{0x41,2,{0x00,0x2F}},

// Sleep Out
{0x11,1,{0x00}},
{REGFLAG_DELAY, 200, {}},

{0x29,1,{0x00}},	
{REGFLAG_DELAY, 10, {}},  
{REGFLAG_END_OF_TABLE, 0x00, {}}       
              
};

//~ static unsigned int GPIO_LCD_PWR_EN;
//~ static unsigned int GPIO_LCD_PWR2_EN;

#ifdef  BUILD_LK
static kal_uint32 rt4801h_write_byte(kal_uint8 addr, kal_uint8 value)
{
    kal_uint32 ret_code = I2C_OK;
    kal_uint8 write_data[2];
    kal_uint16 len;
   struct mt_i2c_t rt4801h_i2c;

    write_data[0]= addr;
    write_data[1] = value;

    rt4801h_i2c.id = I2C0;
    /* Since i2c will left shift 1 bit, we need to set FAN5405 I2C address to >>1 */
    rt4801h_i2c.addr = (0x73 );
    rt4801h_i2c.mode = ST_MODE;
    rt4801h_i2c.speed = 100;
    len = 2;

    ret_code = i2c_write(&rt4801h_i2c, write_data, len);
    printf("%s: i2c_write: ret_code: %d\n", __func__, ret_code);

    return ret_code;
}
#else

#if  1 //defined(MTK_LCM_DEVICE_TREE_SUPPORT)
/*****************************************************************************
 * Define
 *****************************************************************************/
//#ifndef CONFIG_FPGA_EARLY_PORTING
#ifdef CONFIG_MTK_LEGACY
#define LCM_I2C_ADDR 0x73
#define LCM_I2C_BUSNUM  I2C_I2C_LCD_BIAS_CHANNEL	/* for I2C channel 0 */
#define LCM_I2C_ID_NAME "I2C_LCD_BIAS"
#else
#define LCM_I2C_ADDR 0x73
#define LCM_I2C_BUSNUM  0	/* for I2C channel 0 */
#define LCM_I2C_ID_NAME "I2C_LCD_BIAS"
#endif


/*****************************************************************************
 * GLobal Variable
 *****************************************************************************/
#ifdef CONFIG_MTK_LEGACY
static struct i2c_board_info _lcm_i2c_board_info __initdata = {
	I2C_BOARD_INFO(LCM_I2C_ID_NAME, LCM_I2C_ADDR)
};
#else
static const struct of_device_id _lcm_i2c_of_match[] = {
	{
	 .compatible = "mediatek,I2C_LCD_BIAS",
	 },
};
#endif

static struct i2c_client *_lcm_i2c_client;


/*****************************************************************************
 * Function Prototype
 *****************************************************************************/
static int _lcm_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id);
static int _lcm_i2c_remove(struct i2c_client *client);


/*****************************************************************************
 * Data Structure
 *****************************************************************************/
struct _lcm_i2c_dev {
	struct i2c_client *client;

};


static const struct i2c_device_id _lcm_i2c_id[] = {
	{LCM_I2C_ID_NAME, 0},
	{}
};


/* #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)) */
/* static struct i2c_client_address_data addr_data = { .forces = forces,}; */
/* #endif */
static struct i2c_driver _lcm_i2c_driver = {
	.id_table = _lcm_i2c_id,
	.probe = _lcm_i2c_probe,
	.remove = _lcm_i2c_remove,
	/* .detect               = _lcm_i2c_detect, */
	.driver = {
		   .owner = THIS_MODULE,
		   .name = LCM_I2C_ID_NAME,
		   .of_match_table = _lcm_i2c_of_match,
		   },

};


/*****************************************************************************
 * Extern Area
 *****************************************************************************/



/*****************************************************************************
 * Function
 *****************************************************************************/
static int _lcm_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	pr_debug("[LCM][I2C] _lcm_i2c_probe\n");
	pr_debug("[LCM][I2C] NT: info==>name=%s addr=0x%x\n", client->name, client->addr);
	_lcm_i2c_client = client;
	return 0;
}


static int _lcm_i2c_remove(struct i2c_client *client)
{
	pr_debug("[LCM][I2C] _lcm_i2c_remove\n");
	_lcm_i2c_client = NULL;
	i2c_unregister_device(client);
	return 0;
}


    int _lcm_i2c_write_bytes(unsigned char addr, unsigned char value)
{
	

	int ret = 0;

	struct i2c_client *client = _lcm_i2c_client;
	char write_data[2] = { 0 };
	printk("lcm_i2c_addr=%x\n",addr);
	printk("lcm_i2c_value=%x\n",value);
    // printk("lcm_i2c_client=%s\n",client);
	if (client == NULL) {
		printk("ERROR!! _lcm_i2c_client is null\n");
		return 0;
	}

	write_data[0] = addr;
	write_data[1] = value;
	ret = i2c_master_send(client, write_data, 2);
	printk("lcm_i2c_ret=%d\n",ret);
	if (ret < 0)
		printk("[LCM][ERROR] _lcm_i2c write data fail !!\n");

	return ret;
}


/*
 * module load/unload record keeping
 */
static int __init _lcm_i2c_init(void)
{
	pr_debug("[LCM][I2C] _lcm_i2c_init\n");
#ifdef CONFIG_MTK_LEGACY
	i2c_register_board_info(LCM_I2C_BUSNUM, &_lcm_i2c_board_info, 1);
	pr_debug("[LCM][I2C] _lcm_i2c_init2\n");
#endif
	i2c_add_driver(&_lcm_i2c_driver);
	pr_debug("[LCM][I2C] _lcm_i2c_init success\n");

	return 0;
}


static void __exit _lcm_i2c_exit(void)
{
	pr_debug("[LCM][I2C] _lcm_i2c_exit\n");
	i2c_del_driver(&_lcm_i2c_driver);
}


module_init(_lcm_i2c_init);
module_exit(_lcm_i2c_exit);

MODULE_AUTHOR("Joey Pan");
MODULE_DESCRIPTION("MTK LCM I2C Driver");
MODULE_LICENSE("GPL");
//#endif
#endif
#endif



static struct LCM_setting_table lcm_deep_sleep_mode_in_setting[] = {
	// Display off sequence
	{0x28, 0, {0x00}},
{REGFLAG_DELAY, 10, {}},  
    // Sleep Mode On
	{0x10, 0, {0x00}},
{REGFLAG_DELAY, 120, {}},  
	{REGFLAG_END_OF_TABLE, 0x00, {}}
};





static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
{
	unsigned int i;

    for(i = 0; i < count; i++) {
		
        unsigned cmd;
        cmd = table[i].cmd;
		
        switch (cmd) {
			
            case REGFLAG_DELAY :
                MDELAY(table[i].count);
                break;
				
            case REGFLAG_END_OF_TABLE :
                break;
				
            default:
				dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
				//UDELAY(5);//soso add or it will fail to send register
       	}
    }
	
}


// ---------------------------------------------------------------------------
//  LCM Driver Implementations
// ---------------------------------------------------------------------------

static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
{
    memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
}

static void lcm_get_params(LCM_PARAMS *params)
{
    memset(params, 0, sizeof(LCM_PARAMS));

    params->type   = LCM_TYPE_DSI;

    params->width  = FRAME_WIDTH;
    params->height = FRAME_HEIGHT;

    params->physical_width = LCM_PHYSICAL_WIDTH/1000;
    params->physical_height = LCM_PHYSICAL_HEIGHT/1000;
#ifndef BUILD_LK	
    params->physical_width_um = LCM_PHYSICAL_WIDTH;
    params->physical_height_um = LCM_PHYSICAL_HEIGHT;
#endif

	//params->virtual_width = VIRTUAL_WIDTH;
	//params->virtual_height = VIRTUAL_HEIGHT;


	params->dsi.mode = BURST_VDO_MODE;


	/* DSI */
	/* Command mode setting */
	params->dsi.LANE_NUM = LCM_FOUR_LANE;
	/* The following defined the fomat for data coming from LCD engine. */
	params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
	params->dsi.data_format.trans_seq = LCM_DSI_TRANS_SEQ_MSB_FIRST;
	params->dsi.data_format.padding = LCM_DSI_PADDING_ON_LSB;
    params->dsi.data_format.format	  = LCM_DSI_FORMAT_RGB888;
    
	params->dsi.packet_size = 256;
    // Video mode setting		
    params->dsi.intermediat_buffer_num = 0;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
   // params->dsi.packet_size = 256;
    params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
    params->dsi.word_count=720*3;
                //params->dsi.word_count = FRAME_WIDTH*3;
		//params->dsi.vertical_active_line = FRAME_HEIGHT;

	params->dsi.vertical_sync_active				= 8;//2;
	params->dsi.vertical_backporch					= 106;   // from Q driver
	params->dsi.vertical_frontporch					= 130;  // rom Q driver
	params->dsi.vertical_active_line				= FRAME_HEIGHT;

	params->dsi.horizontal_sync_active = 14;
	params->dsi.horizontal_backporch = 25;
	params->dsi.horizontal_frontporch = 45;
	params->dsi.horizontal_active_pixel = FRAME_WIDTH;
	/* params->dsi.ssc_disable                                                   = 1; */
    params->dsi.ssc_disable = 1;
    params->dsi.ssc_range = 0; 
    
    params->dsi.HS_TRAIL=7;

	params->dsi.PLL_CLOCK = 245;	/* this value must be in MTK suggested table */

}





static void lcm_init(void)
{

	#ifdef BUILD_LK
	MDELAY(60);
	rt4801h_write_byte(0x00,0x12);//+5.8v
	rt4801h_write_byte(0x01,0x12);//-5.8v
	MDELAY(20);
    #else
    MDELAY(60);
	_lcm_i2c_write_bytes(0x00,0x12);//+5.8v
	_lcm_i2c_write_bytes(0x01,0x12);//-5.8v
	MDELAY(20);
   #endif
#ifdef BUILD_LK	
    SET_RESET_PIN(1);
    MDELAY(5);	
    SET_RESET_PIN(0);
    MDELAY(10);	
    SET_RESET_PIN(1);
    MDELAY(20);	
#else

#endif
    
	push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
}


static void lcm_suspend(void)
{
	
	push_table(lcm_deep_sleep_mode_in_setting, sizeof(lcm_deep_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);
	




#ifdef BUILD_LK	
    SET_RESET_PIN(0);
    MDELAY(10);	
    SET_RESET_PIN(1);
    MDELAY(10);	
    SET_RESET_PIN(0);
    MDELAY(10);	
#else

#endif

    
}


static void lcm_resume(void)
{
	/*
	 #ifdef BUILD_LK
		printf("%s, lishuwen_test LK 68191 debug: 68191 i\n", __func__);
    #else
		printk("%s, lishuwen_test kernel 68171 horse debug: 68191 \n", __func__);
    #endif
	*/
	lcm_init();
	
	//push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
}

static unsigned int lcm_compare_id(void)
{
	//int   array[4];
	char  buffer[5];
	//unsigned char id_high;
	//unsigned char id_low;
	unsigned int id_boe=0;
	char para_l[2] = {0x5A,0x02};

	MDELAY(100);
	SET_RESET_PIN(1);
	MDELAY(10);
	SET_RESET_PIN(0);
	MDELAY(10);
	SET_RESET_PIN(1);
	MDELAY(30);

	dsi_set_cmdq_V2(0x50, 2, para_l, 1);

	read_reg_v2(0x80, buffer,2);
	//id_high = buffer[0]; ///////////////////////0x98
	id_boe = (buffer[0] << 8) | buffer[1];
	#if defined(BUILD_LK)
		printf("8006u, id_boe = 0x%08x\n",  id_boe);
	#else
		printk("8006u , id_boe = 0x%08x\n",  id_boe);
	#endif
	if(LCM_ID == id_boe)
		return 1;
	else
    	return 0;
}


LCM_DRIVER jd9365_hd720p_dsi_vdo_yg_q6023_lcm_drv = 
{
      .name			= "jd9365_hd720p_dsi_vdo_yg_q6023",
    	//prize-lixuefeng-20150512-start
	#if defined(CONFIG_PRIZE_HARDWARE_INFO) && !defined (BUILD_LK)
	.lcm_info = {
		.chip	= "jd9365",
		.vendor	= "unknow",
		.id		= "0x70",
		.more	= "1520*720",
	},
	#endif
	//prize-lixuefeng-20150512-end	
	.set_util_funcs = lcm_set_util_funcs,
	.get_params     = lcm_get_params,
	.init           = lcm_init,
	.suspend        = lcm_suspend,
	.resume         = lcm_resume,
	.compare_id    = lcm_compare_id,
    };
